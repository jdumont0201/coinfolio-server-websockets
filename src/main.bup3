extern crate time;
extern crate chrono;

use time::precise_time_ns;
use std::thread;
use std::env;
use std::fs::File;
use std::io::prelude::*;
use chrono::prelude::*;
use chrono::offset::LocalResult;
use std::collections::HashMap;

extern crate ws;

use ws::{listen, connect, Handler, Sender, Result, Message, CloseCode};
use std::rc::Rc;
use std::sync::Arc;
use std::sync::Mutex;
use std::sync::MutexGuard;
use std::cell::Cell;
use std::cell::RefCell;

type Registry = Arc<Mutex<Option<HashMap<u32, ws::Sender>>>>;

struct Client {
    out: Sender,
    room_id: Option<String>,
    user_status: Arc<Mutex<HashMap<u32, bool>>>,
    room_users: Registry,
}

impl Handler for Client {
    fn on_open(&mut self, _: ws::Handshake) -> Result<()> {
        if let Some(ref idd) = self.room_id {
            println!("broker opened {}", idd);
            let mut mutex = self.room_users.lock().unwrap();
            if let Some(ref mut o) = *mutex {
                for (id, ref sender) in o.iter() {
                    //println!("[{}] send confirm open", id);
                    if let Ok(rr) = sender.send("{\"created\":\"true\"}") {
                        //  println!("send confirm open ok");
                    } else {
                        // println!("send confirm open err");
                    }
                }
                Ok(())
            } else {
                Ok(())
            }
        } else {
            Ok(())
        }
    }
    fn on_message(&mut self, msg: Message) -> Result<()> {
        //println!("msg {}", msg);
        if let Ok(mut mu) = self.room_users.lock() {
            //println!("  lock ok");
            if let Some(ref mut o) = *mu {
                //let  outs:std::vec::Vec<ws::Sender>=*mutex;
                // let n = o.len();
                //println!("confirm open n  ");
                for (id, ref sender) in o.iter() {
                    let m = msg.to_string().to_owned();
                    println!("  send to {}", id);
                    println!("    check status id {}", id);

                    let hm=self.user_status.lock().unwrap();
                    //if let  Ok(mut st) =  {
                        if let  Some (sta)=hm.get(id){
                        //if let Some(ref mut sta) = *st {

                            println!("    check status = {}", sta);
                            //send
                            if let Ok(rr) = sender.send(m) {
                                println!("    senc confirm ok {}", id);
                                if let Ok(_ping_) = sender.pong(vec!(0)) {
                                    println!("    ping ok {}", id);
                                } else {
                                    println!("    ping closed {}", id);
                                }
                            } else {
                                //  println!("  senc confirm err");
                            }
                        }else{
                            println!("  check status no status");
                        }

                }
                Ok(())
            } else {
                Ok(())
            }
        } else {
            println!("err lock msg");
            Ok(())
        }
    }
}

struct Server {
    out: Sender,
    count: Rc<Cell<u32>>,
    room_counter: Rc<RefCell<HashMap<String, u8>>>,
    user_room: Rc<RefCell<HashMap<u32, String>>>,
    user_isconnected: Arc<Mutex<HashMap<u32, bool>>>,
    id: u32,
    child: Option<std::thread::JoinHandle<()>>,
}

impl Server {
    fn update_room_count(&mut self, room_id: String) {
        println!("* Update room count");
        let mut A = self.room_counter.borrow_mut();
        let mut co = 0;
        if let Some(rc) = A.get(&room_id) {
            println!("Room has a count {}", rc);
            co = *rc;
        } else {
            println!("Room has no count");
        }
        A.insert(room_id, co);
    }
    fn update_user_room(&mut self, room_id: String) {
        //update user room
        println!("* Update user room");
        let mut AA = self.user_room.borrow_mut();
        if let None = AA.get(&self.id) {
            //self.room_counter.borrow_mut().set(room_count);
        } else {
            //elf.room_counter.borrow_mut().set(room_count);
        }
        AA.insert(self.id, room_id);
    }
    fn update_user_isconnected(&mut self) {
        //update user room
        println!("* Update user isconnected SET {} TRUE",self.id);
        let mut AA = self.user_isconnected.lock().unwrap();
        AA.insert(self.id, true);
    }
    fn decrement_room_count(&mut self) {
        println!(" * decrement room_count");
        let mut A = self.user_room.borrow_mut();
        if let Some(room) = A.get(&self.id) {
            let mut B = self.room_counter.borrow_mut();
            let mut has_count = false;
            let mut co = 0;
            if let Some(count) = B.get(room) {
                has_count = true;
                co = *count;
            }
            if has_count {
                B.insert(room.to_string(), co - 1);
            }
        }
    }
    fn update_user_setnotconnected(&mut self) {
        println!("* Update user isconnected");
        let mut AA = self.user_isconnected.lock().unwrap();
        let mut exists = false;
        if let Some(AAA) = AA.get(&self.id) {
            exists = true;
        } else {}
        if exists {
            AA.insert(self.id, false);
        }
    }
}

impl Handler for Server {
    fn on_open(&mut self, hs: ws::Handshake) -> Result<()> {
        let path = hs.request.resource();
        let pathsplit: Vec<&str> = path.split("/").collect();
        let broker: &str = pathsplit[1];
        let pair: &str = pathsplit[2];
        let interval: &str = pathsplit[3];
        println!("User {:?}/{:?} connection : broker {} symbol{} interval{}", self.id, self.count, broker, pair, interval);
        println!("Update total count");
        println!("USER ID {}",self.id);


        let url = get_ws_url(broker, pair, interval);

        let room_id = get_ws_id(broker, pair, interval).to_owned();
        self.update_room_count(room_id);

        let room_id = get_ws_id(broker, pair, interval).to_owned();
        self.update_user_room(room_id);

        self.update_user_isconnected();


        let mut B = HashMap::new();
        let user_id = self.count.get();
        B.insert(user_id, self.out.clone());
        let room_users = Arc::new(Mutex::new(Some(B)));
        let alreadyOpen = false;
        let id = Some(get_ws_id(broker, pair, interval).to_owned());
        let w=self.user_isconnected.clone();
        if alreadyOpen {
            let mut B = HashMap::new();
            let user_id = self.count.get();
            B.insert(user_id, self.out.clone());
            let clients_registry = Arc::new(Mutex::new(Some(B)));
        } else {
            println!("  Try connect to exchange {}", url);
            self.child = Some(thread::spawn(move || {

                println!("  New thread {} ", url);
                connect(url, |out2| Client {
                    out: out2,
                    room_id: id.clone(),
                    room_users: room_users.clone(),
                    user_status:w.clone()
                }).unwrap();
                println!("  New thread done ");
            }));
        }
        println!("  Tried ");
        self.count.set(self.count.get() + 1);
        self.out.send("open done")
    }

    fn on_message(&mut self, msg: Message) -> Result<()> {
        println!("msg {}", msg);
        self.out.send(format!("You are user {} on {:?}", self.id, self.count))
    }

    fn on_close(&mut self, code: CloseCode, reason: &str) {
        match code {
            CloseCode::Normal => println!("The client is done with the connection."),
            CloseCode::Away => {
                println!("The client is leaving the site. Update room count");
                self.update_user_setnotconnected();
                //self.decrement_room_count();
            }
            CloseCode::Abnormal => println!("Closing handshake failed! Unable to obtain closing status from client."),
            CloseCode::Protocol => println!("protocol"),
            CloseCode::Unsupported => println!("Unsupported"),
            CloseCode::Status => println!("Status"),
            CloseCode::Abnormal => println!("Abnormal"),
            CloseCode::Invalid => println!("Invalid"),
            CloseCode::Protocol => println!("protocol"),
            CloseCode::Policy => println!("Policy"),
            CloseCode::Size => println!("Size"),
            CloseCode::Extension => println!("Extension"),
            CloseCode::Protocol => println!("protocol"),
            CloseCode::Restart => println!("Restart"),
            CloseCode::Again => println!("Again"),

            _ => println!("CLOSE The client encountered an error: {}", reason),
        }
    }
    fn on_error(&mut self, err: ws::Error) {
        println!("The server encountered an error: {:?}", err);
    }
}

fn main() {
    static ws_port: i32 = 3014;
    let count = Rc::new(Cell::new(0));

    let A: HashMap<String, u8> = HashMap::new();
    let room_counter = Rc::new(RefCell::new(A));

    let AA: HashMap<u32, String> = HashMap::new();
    let user_room = Rc::new(RefCell::new(AA));


    let AAC: HashMap<u32, bool> = HashMap::new();
    let detailed_dispatch = Arc::new(Mutex::new(AAC));


    if let Err(error) = listen("127.0.0.1:3014", |out| Server {
        out: out,
        //id: id_counter + 1,
        id: count.get(),
        child: None,
        count: count.clone(),
        room_counter: room_counter.clone(),
        user_room: user_room.clone(),
        user_isconnected: detailed_dispatch.clone(),
    }) {
        println!("Failed to create WebSocket due to {:?}", error);
    }
}


fn concat(path: &str, file: &str) -> String {
    let mut owned_str: String = "".to_owned();
    owned_str.push_str(path);
    owned_str.push_str(file);
    owned_str.push_str(".csv");
    owned_str
}

fn get_ws_url(broker: &str, pair: &str, interval: &str) -> String {
    if broker == "binance" {
        let mut s = "wss://stream.binance.com:9443/ws/".to_owned();
        let pairl = pair.to_lowercase();
        s.push_str(&pairl);
        s.push_str("@kline_");
        s.push_str(&interval);
        s
    } else {
        " ".to_owned()
    }
}

static mut counter: usize = 0;

fn get_ws_id(broker: &str, pair: &str, interval: &str) -> String {
    let mut s = broker.to_string();
    s.push_str("-");
    s.push_str(&pair);
    s.push_str("-");
    s.push_str(&interval);
    s
}

fn get_new_hash(id: u32, val: bool) -> HashMap<u32, bool> {
    let mut A: HashMap<u32, bool> = HashMap::new();
    A.insert(id, val);
    A
}